=begin
Функции (методы) в Ruby
опубликовано 27.06.2017 автор admin	в Веб-разработка

В этом посте мы рассмотрим:

Функции/методы
Определения
Как их называть?
Что и как они возвращают?
Аргументы по умолчанию
Как сделать методы более выразительными
Что такое «splat»
Функции и методы
Технически, функция определяется за пределами класса, а метод определяется внутри класса.

В Ruby, каждый метод/функция имеет как минимум один класс, к которому он пренадлежит.

Не всегда записан внутри класса
Таким образом, каждая функция на самом деле является методом в Ruby.

Методы
Методы могут иметь скобки, но они полностью опциональны как при определении метода,
 так и при вызове метода.

Скобки используются для ясности, хотя это и не необходимо.


def simple
  puts "без скобок"
end

def simple1()
  puts "со скобками"
end

simple() # => без скобок
simple # => без скобок
simple1 # => со скобками

В этом примере мы определили метод simple без скобок, но мы его можем вызвать как со скобками, 
так и без, — и это полностью разрешено. То же самое относится и к методу simple1.

Возврат
Нет необходимости объявлять тип параметров
Может возвращать всё, что вы хотите
Ключевое слово return опционально (возвращается последняя выполненная строка)

def add(one, two)
 one + two
end

def divide(one, two)
  return "Я так не думаю" if two == 0
  one / two
end

puts add(2,2) # => 4
puts divide(2,0) # => Я так не думаю
puts divide(12, 4) # => 3

Выразительные имена методов
Имена методов могут оканчиваться на:

? — основанные на чем-то методы (как правило, возвращает логическое значение)
! — может иметь опасные побочные эффекты

def can_divide_by?(number)
  return false if number.zero?
  true
end

puts can_divide_by? 3 # => true
puts can_divide_by? 0 # => false

Аргументы по умолчанию
Методы могут иметь аргументы по умолчанию.

Если внесено значение — используется данное значение
В другом случае — используется значение по умолчанию

def factorial (n)
  n ==? 1 : n * factorial(n - 1)
end

def factorial_with_default (n = 5)
  n ==0? 1 : n * factorial_with_default(n - 1)
end

puts factorial 5 # => 120
puts factorial_with_default # => 120
puts factorial_with_default(3) # => 6

Splat
Splat — это интересная концепция.

* идет перед параметром в определении метода

Может применяться даже к параметру посередине, а не только последнему
Он почти похож на указатель, как указатель в C, но это не так. Это похоже на var args, 
переменные аргументы в Java.

Итак, у вас есть много параметров которые вы хотите передать, но вы не знаете сколько,
 или вам неважно сколько. Вы хотите, чтобы все параметры обрабатывались как один параметр, 
 и все эти параметры становятся одним большим массивом внутри метода.

И интересная часть заключается в том, что он может относиться к среднему параметру, 
а не только к последнему параметру метода.


def max(one_param, *numbers, another)
  numbers.max
end

puts max("что-то", 6, 31, -5, "еще") # => 31

=end
def move(starting, goal)
    # your code here
   
    moveTo = (1..3).find {|n| n != starting && n != goal} 
    "#{starting}->#{moveTo} #{starting}->#{goal} #{moveTo}->#{goal}"
  
  end
  puts move(1, 3)
  # => 1->2 1->3 2->3
  
  puts move(2, 3)
  # => 2->1 2->3 1->3